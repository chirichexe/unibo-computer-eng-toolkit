Catena pre-routing del nodo nat = Catena pre-routing nella tabella nat

Catena pre-routing nodo nat ci interessa per cambiare la destinazione indicata sul pacchetto
Catena forward nodo filter per forwardare/impedire il passaggio di un pacchetto
Catena Input nodo filter rappresenta la 1a metà del personal firewall
Catena Output nodo filter rappresenta la 2a metà del personal firewall
Catena pre-routing nodo nat ci interessa per cambiare l'IP del mittente indicato sul pacchetto

Le regole che fanno scattare i vari nodi sono dei banali if che controllano match
Ogni regola ha 2 contatori che scattano quando un paccheto fa match: 1 per contare quanti pacchetti sono passati e 1 per contare i byte fin ora trasportati.
Se mettessi una regola con target vuoto ogni pacchetto farebbe match e potrei usare i due contatori per monitorare il traffico


Dopo un accept, il pacchetto non viene inviato. Solo dopo che tutti i nodi hanno confermato un ACCEPT il pacchetto passa
Dopo anche 1 solo drop, il pacchetto viene scartato

PER LA TABELLA NAT
- nelle catene prerouting o output si può specificare un destination address diverso (DNAT)
- nelle cate postrouting o input si può specficare un source address diverso (SNAT)

man iptables ed iptables-extensions (state, )

Tutto quello che passa dalla macchina host interessa le catene di INPUT o OUTPUT


Booklet : https://virtuale.unibo.it/mod/book/view.php?id=1510550

PAG 1.5
Nella macchina R1 (comandi effimeri. Si disattivano al prossimo vagrant up)
- voglio permettere a s1 di loggarsi con ssh
- iptables -A INPUT -s 10.0.2.2 -d 10.0.2.15 -i eth0 -p tcp --dport 22 -j ACCEPT
	INPUT è la catena
	(-s è source e -d è dest) 
	-p è il protocollo
	-input della macchina host (eth0 per il lab)
	-d è la porta su cui controlleremo i pacchetti
	-j indica cosa fare
- vediamo se ha funzionato facendo iptables -vnL INPUT
- non abbiamo finito perché i pacchetti hanno la risposta
- aggiungiamo iptables -A OUTPUT -d 10.0.2.2 -s 10.0.2.15 -o eth0 -p tcp --sport 22 -j ACCEPT

- duiciamo ora che il routrer deve ribioutare tutti gli altri pacchetti
	iptables -P INPUT DROP
	iptables -P OUTPUT DROP
- così facendo, nessun pacchetto viene fatto passare, a parte quelli della macchina adatta s1
- un ssh 10.1.1.254 su client non da risultato

PAG 2
Creiamo un firewall per consentire il traffico tra la rete dei client e quella dei server
Nella macchina R1
- iptables -A FORWARD -i eth1 -o eth2 -s 10.1.1.0/24 -d 10.2.2.0/24 -j ACCEPT -> si possono usare indirizzi di subnet
	tutto ciò che entra in eth1 e esce da eth2 proveniente dalla rete dei client e diretta verso la rete dei server S1 è accettato
- iptables -A FORWARD -i eth1 -o eth2 -s 10.1.1.0/24 -d 10.3.3.0/24 -j ACCEPT
	idem ma per la rete di S2
- Mancano le regole di ritorno
	iptables -A FORWARD -o eth1 -i eth2 -d 10.1.1.0/24 -s 10.2.2.0/24 -j ACCEPT
	iptables -A FORWARD -o eth1 -i eth2 -d 10.1.1.0/24 -s 10.3.3.0/24 -j ACCEPT
- Aggiorniamo la policy per tutti gli altri indirizzi -> iptables -P FORWARD DROP
- Vediamo le nostre regole con -> iptables -vnL FORWARD 

Supponiamo di esserci sbagliati e non si voglia che i client raggiungano R2. Come vambiare?
- riprendere i 2 comandi tra  1.1 a 3.3 e sostituire la flag -A con -D
- IN ALTERNATIVA A SOPRA: 
	iptables -vnL FORWARD --line-numbers
	iptables -D FORWARD [numero] -> regola eliminata!
- iptables -F FORWARD -> pulisce le regole di tutta la tabella
- proviamo a fare un piccolo file in cui rimettere le regole (copiare le righe del booklet) -> lanciarlo con bash "nomefile"
- usare -I al posto di -A la mette in testa invece che in coda 
	-> le regole sono controllate nell'ordine mostrato -> mettere prima le più specifiche, poi le più generiche

PAG 2.5
Configurare il Firewall di S1 per accettare connessioni SSH da tutte le VM della rete dei client evvetto 10.0.1.1.1
Configurare la salvaguardia per poter accedere via vagrant
Bloccare qualunque altro accesso SSH
non bloccare OUT ma solo INPUT

iptables -P INPUT ACCEPT -> ripristino
iptables -P OUTPUT ACCEPT -> ripristino
iptables -F INPUT

iptables -A INPUT -s 10.1.1.1 -d 10.2.2.1 -i eth1 -p tcp --dport 22 -j DROP
iptables -A INPUT -s 10.1.1.0/24 -d 10.2.2.1 -i eth1 -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -s 10.0.2.2 -d 10.0.2.15 -i eth0 -p tcp --dport 22 -j ACCEPT    -> salvaguardia
iptables -P INPUT DROP

PAG 2.5.5
Quando un pacchetto lascia una macchina (REQ) iptables si segna che quella connessione (ovvero la quintupla <IPsource, IPdest, PORTsource, PORTdest, PROTOCOL>)
è ESTABLISHED. Pertanto, pacchetti di risposta (RES) lungo la medesima connessione avranno la flag ESTABLISHED.
E' quindi possibile accettare solo risposte ESTABLISHED, ovvero le vere risposte, evitando di accettare RES da router o server "fasulli"


## client -> devo consentire che si connetta sulla macchina S2 con ssh
iptables -A OUTPUT -s 10.1.1.1 -d 10.3.3.1 -o eth1 -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -s 10.3.3.1 -d 10.1.1.1 -i eth1 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 

## r1
iptables -A FORWARD -s 10.1.1.1 -d 10.3.3.1 -i eth1 -o eth2 -p tcp --dport 22 -j ACCEPT
iptables -A FORWARD -s 10.3.3.1 -d 10.1.1.1 -i eth2 -o eth1 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT

## r2
iptables -A FORWARD -s 10.1.1.1 -d 10.3.3.1 -i eth2 -o eth3 -p tcp --dport 22 -j ACCEPT
iptables -A FORWARD -s 10.3.3.1 -d 10.1.1.1 -i eth3 -o eth2 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 

## server
iptables -A OUTPUT -s 10.3.3.1 -d 10.1.1.1 -o eth1 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
iptables -A INPUT -s 10.1.1.1 -d 10.3.3.1 -i eth1 -p tcp --dport 22 -j ACCEPT

PAG 5 -> tutto come nella pagina
	In R1 tutti i pacchetti che vengono dal client e sono destinati a R1 subiscono un cambio di destinazione verso S1
	
	In quanto la direttiva è per la catena PREROUTING, la regola descritta sopra viene rispettata anche se la macchina S1 è isolata sulla catena INPUT.
	Questo avviene perché le regole della catena di PREROUTING avvengono prima di quelle della catena di INPUT
	















