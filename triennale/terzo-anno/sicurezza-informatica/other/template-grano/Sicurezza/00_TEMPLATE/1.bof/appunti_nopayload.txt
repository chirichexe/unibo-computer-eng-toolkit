RICORDA: `echo 0 > /proc/sys/kernel/randomize_va_space`
RICORDA: esp prima cella libera

=================================ALLINEA STACK=================================
URL: https://stackoverflow.com/questions/1147623/trying-to-understand-gccs-complicated-stack-alignment-at-the-top-of-main-that-c

;# As you have already noticed, the compiler wants to align the stack
;# pointer on a 16 byte boundary before it pushes anything. That's
;# because certain instructions' memory access needs to be aligned
;# that way.
;# So in order to first save the original offset of esp (+4), it
;# executes the first instruction:
lea    ecx,[esp+0x4]

;# Now alignment can happen. Without the previous inst the next one
;# would have made the original esp unrecoverable:
and    esp,0xfffffff0

;# Next it pushes the return addresss and creates a stack frame. I
;# assume it now wants to make the stack look like a normal
;# subroutine call:
push   DWORD PTR [ecx-0x4]
push   ebp
mov    ebp,esp

;# Remember that ecx is still the only value that can restore the
;# original esp. Since ecx may be garbled by any subroutine calls,
;# it has to save it somewhere:
push   ecx

===========================COME VIENE PRESO ARGV[1]============================
`ecx` contiene il il primo dato sul vecchio stack, possiamo dare per scontato
che siano gli argomenti di main

mov    eax,ecx                 ;; eax <- args
mov    eax,DWORD PTR [eax+0x4] ;; eax <- argv
add    eax,0x4                 ;; eax <- argv + 1
mov    eax,DWORD PTR [eax]     ;; eax <- argv[1]
push   eax

===========================STACK ALLA CHIAMATA VULN============================
cosa c'Ã¨ in memoria alla chiamata di <vuln>


               +-------------------+
+0x8           | argc
               +-------------------+
+0x4           | RET ADDR MAIN (0xf7dfab41) (kinda weird ma vbb)
               +-------------------+
EBP 0xffffdc38 | OLD EBP (0x00000000) (ebp not really used anymore)
               +-------------------+
-0x4           | old ESP (0xffffdc50)
               +-------------------+
-0x8           | dont know (0xf7fe4520)
               +-------------------+
...
               +-------------------+
-0x14          | argv[1] 
               +-------------------+
-0x18 ESP      |
               +-------------------+

==============================CHE FA DOPO LA VULN==============================
riporta lo $esp al valore prima di allinearlo per la main
(old ESP, se l'era salvato sullo stack)

=============================VULN PRIMA DI STRCPY==============================
 * crea frame
 * salva ebx (callee saved)
 * riserva una marea di spazio sullo stack (0x5f4 + 0x8)
 * mette sullo stack il primo argomento a vuln (argv[1])
 * mette sullo stack il puntatore $ebp - 0x5ee (aka buf)
 * chiama strcpy
 * toglie 0x4 dallo stack
 * mette buf sullo stack
 * chiama puts
 * restore ebx
 * leave



